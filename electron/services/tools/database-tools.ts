/**
 * Database Tools - PostgreSQL/Prisma operations for the agent
 */

import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { readFile, writeFile, access, mkdir } from 'node:fs/promises';
import path from 'node:path';
import { Tool, ToolContext, defineTool } from './registry';

const execAsync = promisify(exec);

// Type definitions for tool parameters
interface ProposeSchemaParams {
  description: string;
  existingSchema?: string;
}

interface InspectSchemaParams {
  schemaPath?: string;
}

interface WriteSchemaParams {
  content: string;
  schemaPath?: string;
}

interface CreateMigrationParams {
  name: string;
}

interface ApplyMigrationParams {
  skipGenerate?: boolean;
}

interface PushSchemaParams {
  acceptDataLoss?: boolean;
}

interface SeedDatabaseParams {
  profile?: 'demo' | 'test' | 'minimal';
}

interface ResetDatabaseParams {
  force?: boolean;
}

/**
 * Propose a Prisma schema based on natural language description
 */
export const proposeSchema = defineTool<ProposeSchemaParams>(
  'propose_schema',
  'Generate a Prisma schema from a natural language description of the data model',
  {
    type: 'object',
    properties: {
      description: {
        type: 'string',
        description: 'Natural language description of the data model (e.g., "Users with posts and comments")'
      },
      existingSchema: {
        type: 'string',
        description: 'Existing Prisma schema to extend (optional)'
      }
    },
    required: ['description']
  },
  async (params: ProposeSchemaParams, _context: ToolContext) => {
    // This tool is designed to be used with AI - it returns a template
    // that the AI model will fill in based on the description
    const template = `// Prisma Schema for: ${params.description}
// Generated by Singularity IDE

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// TODO: Define models based on the description
// The AI agent will fill this in based on: "${params.description}"
`;

    return {
      success: true,
      data: {
        template,
        description: params.description,
        hint: 'The AI agent should generate appropriate Prisma models based on the description'
      }
    };
  }
);

/**
 * Read and parse the current Prisma schema
 */
export const inspectSchema = defineTool<InspectSchemaParams>(
  'inspect_schema',
  'Read and analyze the current Prisma schema file',
  {
    type: 'object',
    properties: {
      schemaPath: {
        type: 'string',
        description: 'Path to schema.prisma file (defaults to prisma/schema.prisma)'
      }
    },
    required: []
  },
  async (params: InspectSchemaParams, context: ToolContext) => {
    const schemaPath = params.schemaPath || path.join(context.projectRoot, 'prisma', 'schema.prisma');

    try {
      await access(schemaPath);
      const content = await readFile(schemaPath, 'utf-8');

      // Parse basic schema info
      const models = content.match(/model\s+(\w+)\s*{/g)?.map(m => m.match(/model\s+(\w+)/)?.[1]) || [];
      const enums = content.match(/enum\s+(\w+)\s*{/g)?.map(e => e.match(/enum\s+(\w+)/)?.[1]) || [];
      const provider = content.match(/provider\s*=\s*"(\w+)"/)?.[1] || 'unknown';

      return {
        success: true,
        data: {
          path: schemaPath,
          content,
          models,
          enums,
          provider,
          modelCount: models.length,
          enumCount: enums.length
        }
      };
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return {
          success: false,
          error: {
            message: 'Schema file not found',
            code: 'SCHEMA_NOT_FOUND',
            recoverable: true
          }
        };
      }
      return {
        success: false,
        error: {
          message: `Failed to read schema: ${error.message}`,
          code: 'READ_ERROR',
          recoverable: false
        }
      };
    }
  }
);

/**
 * Write/update the Prisma schema
 */
export const writeSchema = defineTool<WriteSchemaParams>(
  'write_schema',
  'Write or update the Prisma schema file',
  {
    type: 'object',
    properties: {
      content: {
        type: 'string',
        description: 'The complete Prisma schema content'
      },
      schemaPath: {
        type: 'string',
        description: 'Path to schema.prisma file (defaults to prisma/schema.prisma)'
      }
    },
    required: ['content']
  },
  async (params: WriteSchemaParams, context: ToolContext) => {
    const schemaPath = params.schemaPath || path.join(context.projectRoot, 'prisma', 'schema.prisma');

    try {
      // Ensure prisma directory exists
      const prismaDir = path.dirname(schemaPath);
      await mkdir(prismaDir, { recursive: true });

      // Backup existing schema if it exists
      let backup: string | undefined;
      try {
        const existing = await readFile(schemaPath, 'utf-8');
        backup = schemaPath + '.backup';
        await writeFile(backup, existing);
      } catch {
        // No existing file to backup
      }

      await writeFile(schemaPath, params.content);

      return {
        success: true,
        data: {
          path: schemaPath,
          size: params.content.length
        },
        rollback: backup ? {
          type: 'restore_file' as const,
          path: schemaPath,
          backup
        } : {
          type: 'delete_file' as const,
          path: schemaPath
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Failed to write schema: ${error.message}`,
          code: 'WRITE_ERROR',
          recoverable: false
        }
      };
    }
  }
);

/**
 * Generate Prisma client
 */
export const generatePrismaClient = defineTool<Record<string, never>>(
  'generate_prisma_client',
  'Run prisma generate to create the Prisma client',
  {
    type: 'object',
    properties: {},
    required: []
  },
  async (_params: Record<string, never>, context: ToolContext) => {
    try {
      const { stdout, stderr } = await execAsync('npx prisma generate', {
        cwd: context.projectRoot,
        timeout: context.securityConfig.maxExecutionTime
      });

      return {
        success: true,
        data: {
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Prisma generate failed: ${error.message}`,
          code: 'GENERATE_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * Create a database migration
 */
export const createMigration = defineTool<CreateMigrationParams>(
  'create_migration',
  'Create a new Prisma migration',
  {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        description: 'Name for the migration (e.g., "add_user_posts")'
      }
    },
    required: ['name']
  },
  async (params: CreateMigrationParams, context: ToolContext) => {
    try {
      // Sanitize migration name
      const migrationName = params.name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();

      const { stdout, stderr } = await execAsync(
        `npx prisma migrate dev --name ${migrationName} --create-only`,
        {
          cwd: context.projectRoot,
          timeout: context.securityConfig.maxExecutionTime
        }
      );

      return {
        success: true,
        data: {
          migrationName,
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Migration creation failed: ${error.message}`,
          code: 'MIGRATION_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * Apply database migrations
 */
export const applyMigration = defineTool<ApplyMigrationParams>(
  'apply_migration',
  'Apply pending Prisma migrations to the database',
  {
    type: 'object',
    properties: {
      skipGenerate: {
        type: 'boolean',
        description: 'Skip running prisma generate after migration'
      }
    },
    required: []
  },
  async (_params: ApplyMigrationParams, context: ToolContext) => {
    try {
      const { stdout, stderr } = await execAsync('npx prisma migrate dev', {
        cwd: context.projectRoot,
        timeout: context.securityConfig.maxExecutionTime
      });

      return {
        success: true,
        data: {
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Migration failed: ${error.message}`,
          code: 'MIGRATION_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * Push schema changes directly (for development)
 */
export const pushSchema = defineTool<PushSchemaParams>(
  'push_schema',
  'Push schema changes directly to the database (development only, no migration files)',
  {
    type: 'object',
    properties: {
      acceptDataLoss: {
        type: 'boolean',
        description: 'Accept potential data loss from destructive changes'
      }
    },
    required: []
  },
  async (params: PushSchemaParams, context: ToolContext) => {
    try {
      const command = params.acceptDataLoss
        ? 'npx prisma db push --accept-data-loss'
        : 'npx prisma db push';

      const { stdout, stderr } = await execAsync(command, {
        cwd: context.projectRoot,
        timeout: context.securityConfig.maxExecutionTime
      });

      return {
        success: true,
        data: {
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Schema push failed: ${error.message}`,
          code: 'PUSH_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * Seed the database
 */
export const seedDatabase = defineTool<SeedDatabaseParams>(
  'seed_database',
  'Run the database seed script',
  {
    type: 'object',
    properties: {
      profile: {
        type: 'string',
        enum: ['demo', 'test', 'minimal'],
        description: 'Seed data profile to use'
      }
    },
    required: []
  },
  async (params: SeedDatabaseParams, context: ToolContext) => {
    try {
      const { stdout, stderr } = await execAsync('npx prisma db seed', {
        cwd: context.projectRoot,
        timeout: context.securityConfig.maxExecutionTime,
        env: {
          ...process.env,
          SEED_PROFILE: params.profile || 'demo'
        }
      });

      return {
        success: true,
        data: {
          profile: params.profile || 'demo',
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Seeding failed: ${error.message}`,
          code: 'SEED_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * Reset the database
 */
export const resetDatabase = defineTool<ResetDatabaseParams>(
  'reset_database',
  'Reset the database (drops all data and re-applies migrations)',
  {
    type: 'object',
    properties: {
      force: {
        type: 'boolean',
        description: 'Skip confirmation prompt'
      }
    },
    required: []
  },
  async (_params: ResetDatabaseParams, context: ToolContext) => {
    // Only allow in pro mode
    if (context.securityConfig.networkAccess === 'localhost-only') {
      return {
        success: false,
        error: {
          message: 'Database reset is not allowed in kid mode',
          code: 'NOT_ALLOWED',
          recoverable: false
        }
      };
    }

    try {
      // Always force in automated context
      const command = 'npx prisma migrate reset --force';

      const { stdout, stderr } = await execAsync(command, {
        cwd: context.projectRoot,
        timeout: context.securityConfig.maxExecutionTime
      });

      return {
        success: true,
        data: {
          output: stdout,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Database reset failed: ${error.message}`,
          code: 'RESET_ERROR',
          recoverable: false
        }
      };
    }
  }
);

/**
 * Check database connection
 */
export const checkDatabaseConnection = defineTool<Record<string, never>>(
  'check_database_connection',
  'Verify the database connection is working',
  {
    type: 'object',
    properties: {},
    required: []
  },
  async (_params: Record<string, never>, context: ToolContext) => {
    try {
      // Use prisma db pull --force to test connection without modifying schema
      await execAsync('npx prisma db execute --stdin', {
        cwd: context.projectRoot,
        timeout: 30000
      });

      return {
        success: true,
        data: {
          connected: true,
          message: 'Database connection successful'
        }
      };
    } catch (error: any) {
      // Try alternative check
      try {
        await execAsync('npx prisma migrate status', {
          cwd: context.projectRoot,
          timeout: 30000
        });
        return {
          success: true,
          data: {
            connected: true,
            message: 'Database connection successful'
          }
        };
      } catch {
        return {
          success: false,
          error: {
            message: `Database connection failed: ${error.message}`,
            code: 'CONNECTION_ERROR',
            recoverable: true
          }
        };
      }
    }
  }
);

/**
 * Get migration status
 */
export const getMigrationStatus = defineTool<Record<string, never>>(
  'get_migration_status',
  'Get the status of database migrations',
  {
    type: 'object',
    properties: {},
    required: []
  },
  async (_params: Record<string, never>, context: ToolContext) => {
    try {
      const { stdout, stderr } = await execAsync('npx prisma migrate status', {
        cwd: context.projectRoot,
        timeout: 30000
      });

      // Parse migration status
      const hasPending = stdout.includes('Following migration') || stdout.includes('have not yet been applied');
      const isInSync = stdout.includes('Database schema is up to date');

      return {
        success: true,
        data: {
          output: stdout,
          hasPendingMigrations: hasPending,
          isInSync,
          warnings: stderr || undefined
        }
      };
    } catch (error: any) {
      return {
        success: false,
        error: {
          message: `Failed to get migration status: ${error.message}`,
          code: 'STATUS_ERROR',
          recoverable: true
        }
      };
    }
  }
);

/**
 * All database tools
 */
export const DATABASE_TOOLS: Tool[] = [
  proposeSchema,
  inspectSchema,
  writeSchema,
  generatePrismaClient,
  createMigration,
  applyMigration,
  pushSchema,
  seedDatabase,
  resetDatabase,
  checkDatabaseConnection,
  getMigrationStatus
];

/**
 * Register database tools with a registry
 */
export function registerDatabaseTools(registry: import('./registry').ToolRegistry): void {
  for (const tool of DATABASE_TOOLS) {
    registry.register(tool);
  }
}

export default DATABASE_TOOLS;
